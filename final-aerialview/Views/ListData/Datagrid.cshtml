@model ListDataViewModel
@using Newtonsoft.Json
@using System.Web


@{
    ViewData["Title"] = @Model.ChildMenuName;
    Layout = null;
}


<div id="dataTable" class="position-relative shadow rounded" data-table-name="@Model.TableName" data-child-menu-name="@Model.ChildMenuName" data-conn-string="@Model.ConnectionString">
    @if (Model.TableData == null || !Model.TableData.Any())
    {
        <div id="loadingSpinnerContainer" class="h-100 w-100 d-flex align-items-center justify-content-center">
            <div id="loadingSpinner" class="d-none">
                <div class="spinner-grow text-primary-emphasis" role="status" style="width: 1.5rem; height: 1.5rem; animation-duration: 1s;">
                    <span class="visually-hidden">Loading...</span>
                </div>
            </div>
            <p id="noDataMessage" class="text-body-secondary fw-medium">No data to show</p>
            <p id="errorMessage" class="text-danger fw-medium d-none text-center">
                There was an issue accessing the data. <br /> Please contact your administrator for assistance.
            </p>
        </div>
    }
    else
    {
        <div class="datagridWrapper bg-light bg-gradient rounded-top">
            @(
                Html.DevExtreme().DataGrid()
                .ID("dataGridContainer")
                .ShowBorders(true)
                .ColumnMinWidth(60)
                .Scrolling(scrolling => scrolling.ColumnRenderingMode(GridColumnRenderingMode.Standard))
                .DataSource(Model.TableData)
                .FilterRow(filterRow => filterRow
                .Visible(true)
                .ApplyFilter(GridApplyFilterMode.Auto)
                )
                .StateStoring(s => s
                .Enabled(true)
                .Type(StateStoringType.LocalStorage)
                .StorageKey("storage")
                )
                .Editing(editing =>
                {
                    editing.Mode(GridEditMode.Batch);
                    @* editing.AllowUpdating(true); *@
                    editing.AllowUpdating(new JS("localStorage.getItem('isEditingEnabled') === 'true'"));
                })
                .ColumnAutoWidth(true)
                .AllowColumnReordering(true)
                .AllowColumnResizing(true)
                .ColumnResizingMode(ColumnResizingMode.Widget)
                .ShowColumnLines(true)
                .ShowRowLines(true)
                .ColumnChooser(c => c.Enabled(true))
                .ColumnFixing(c => c.Enabled(true))
                .WordWrapEnabled(true)
                .HoverStateEnabled(true)
                .HeaderFilter(hf => hf
                .Visible(true)
                .Search(hfs => hfs.Enabled(true))
                )
                .GroupPanel(g => g.Visible(true))
                .Grouping(g => g.AutoExpandAll(false))


                .Columns(c =>
                {
                    if (Model.TableData != null && Model.TableData.Any() && Model.ConditionalTableData != null)
                    {
                        var firstItem = Model.TableData.FirstOrDefault() as IDictionary<string, object>;

                        if (firstItem != null)
                        {
                            @* var str = ""; *@
                            foreach (var i in Model.ConditionalTableData)
                            {
                                foreach (var property in firstItem.Keys)
                                {
                                    if (property == i.ColumnName)
                                    {
                                        var column = c.Add().DataField(property).Caption(i.DisplayName)
                                        .CssClass("datagridCol");
                                        @* Set the editing ability based on the EditableColumn property *@
                                        if (i.EditableColumn)
                                        {
                                            column.AllowEditing(true);
                                        }
                                        else
                                        {
                                            column.AllowEditing(false);
                                        }

                                        @* Specific handling for DateAndTime *@
                                        if (property == "DateAndTime")
                                        {
                                            column.DataType(GridColumnDataType.DateTime)
                                            .Format("dd-MM-yyyy HH:mm:ss")
                                            .AllowEditing(false)
                                            .AllowHiding(false);
                                        }
                                    }
                                }

                            }

                        }
                    }

                    @* Calculated Field *@
                    if (Model.CalculatedFields != null && Model.CalculatedFields.Any())
                    {
                        foreach (var calcField in Model.CalculatedFields)
                        {
                            c.Add()
                    .DataField(calcField.ColumnName)
                    .Caption(calcField.ColumnName)
                    .CssClass("datagridCol")

                    .CalculateCellValue(@<text>
            function CalculateProductTotal(e) {
            var formula = "@Html.Raw(calcField.Formula)"; // Retrieve the formula

            // Log the current row values for debugging
            @* console.log("Calculating for:", e); *@

            // Replace column names with their values or default to 0
            var evaluatedFormula = formula.replace(/([A-Za-z_]\w*)/g, function(match) {
            const value = e[match] !== undefined && e[match] !== null ? e[match] : 0; // Default to 0
            @* console.log(`Substituting ${match} with ${value}`); *@ // Log substitutions
            return value;
            });

            try {
            // Evaluate the formula
            var result = eval(evaluatedFormula);

            // Check for Infinity or NaN
            if (result === Infinity || result === -Infinity || isNaN(result)) {
            console.error("Calculation resulted in Infinity or NaN", evaluatedFormula);
            return 0; // Return 0 if result is invalid
            }

            return result; // Return the valid result
            } catch (error) {
            console.error("Error evaluating formula:", error); // Log errors
            return 0; // Return 0 in case of error
            }
            }

        </text>)

        .Format(f => f.Type(Format.FixedPoint).Precision(2))
        .AllowEditing(false);  @* Adjust based on your logic for editing *@
                        }
                    }
                })
                .ShowColumnHeaders(true)
                .Pager(pager =>
                {
                    pager.Visible(true);
                    pager.DisplayMode(GridPagerDisplayMode.Compact);
                    pager.ShowPageSizeSelector(true);
                    pager.AllowedPageSizes(new JS("[5, 10, 'all']"));
                    pager.ShowInfo(true);
                    pager.ShowNavigationButtons(true);
                })

                .Paging(paging =>
                {
                    paging.Enabled(true);
                    paging.PageSize(10);
                })
                .OnSaving("onSaving")
                )
        </div>

        <div class="exportBtn position-sticky bg-white d-flex justify-content-between align-items-center gap-2 border-top ps-2">

            <button type="button" class="btn  btn-sm border-white shadow fw-medium" data-bs-toggle="modal" data-bs-target="#calculatedFieldModal">
                <p class="fw-semibold  mb-0" style="color: #1D6F42;"><i class="ri-add-line"></i> Calculated field</p>
            </button>


            <div class=" d-flex align-items-center gap-2">

                <div id="exportOrientation" class="ms-2">
                    <div class="input-group input-group-sm">
                        <label class="input-group-text" for="pdfOrientationSelect"><i class="bi bi-printer"></i></label>
                        <select id="pdfOrientationSelect" class="form-select form-select-sm" aria-label="Small select example" style="cursor: pointer !important;">
                            <option value="landscape" selected>Landscape</option>
                            <option value="portrait">Portrait</option>
                        </select>
                    </div>
                </div>


                <button title="Export To Excel" id="excelExportButton" class="btn btn-sm  text-decoration-none text-dark p-0">
                    <i class="ri-file-excel-2-line fs-3 shadow-sm" style="color: #1D6F42;"></i>
                    @* <i class="ri-file-excel-2-line fs-3 shadow-sm text-success"></i> *@
                </button>
                <button title="Export To PDF" id="pdfExportButton" class="btn btn-sm text-decoration-none text-dark p-0">
                    <i class="ri-file-pdf-2-line fs-3 shadow-sm" style="color: #F40F02;"></i>
                    @* <i class="ri-file-pdf-2-line fs-3 shadow-sm text-danger"></i> *@
                </button>
            </div>

        </div>
    }
</div>

@* Modal for users to input their formulas for calculated fields *@
<div class="modal fade bg-secondary bg-gradient bg-opacity-25 " id="calculatedFieldModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header p-2 px-3">
                <h6 class="modal-title text-primary-emphasis fw-bold" id="formulaModalLabel" style="word-spacing: 0.1rem">Create Custom Formula Field</h6>
                <button type="button" class="btn-close btn-sm" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <form id="formulaForm">

                    @if (Model.CalculatedFields != null && Model.CalculatedFields.Any())
                    {
                        <div class="mb-3">
                            <label for="existingFieldsDropdown" class="form-label fs-6 fw-semibold" style="font-size: .9rem !important;">Select Existing Field</label>
                            <select id="existingFieldsDropdown" class="form-select fw-medium" style="font-size: .8rem !important;" onchange="handleFieldSelection(this)">
                                <option value="" selected disabled>Select a field to update</option>
                                @foreach (var calcField in Model.CalculatedFields)
                                {
                                    <option class="fw-medium" value="@calcField.Id" data-formula="@calcField.Formula"
                                            data-column-name="@calcField.ColumnName">@calcField.ColumnName</option>
                                }
                            </select>
                        </div>
                    }

                    @* Input for custom field name  *@
                    <div class="mb-3">
                        <label for="columnNameInput" class="form-label fs-6 fw-semibold" style="font-size: .9rem !important;">Custom Column Name</label>
                        <input type="text" class="form-control fw-medium" id="columnNameInput" style="font-size: .8rem !important;" placeholder="Enter a name for your calculated field" oninput="handleColumnNameVal(this.value)" required>
                        <span id="duplicateName-message" class=" text-danger" style="display:none; font-size: 14px;">!</span>
                        <div class="invalid-feedback text-danger">Example invalid feedback text</div>
                    </div>
                 
                    @* Input for formula *@
                    <div class="mb-3">
                        <label for="formulaInput" class="form-label fs-6 fw-semibold" style="font-size: .9rem !important;">Calculation Formula</label>
                        <input type="text" class="form-control fw-medium" id="formulaInput" style="font-size: .8rem !important;" placeholder="e.g., Column1 + Column2" autocomplete="off" oninput="handleFormulaInput(this.value)" required>
                        <span id="error-message" class=" text-danger" style="display:none; font-size: 14px;">!</span>
                    </div>

                    <input type="hidden" name="rptId" value="@Model.RptId" />
                    <input type="hidden" name="calcFieldId" id="calculatedFieldId" />

                    @* Output section to show formula result  *@
                    <div class="mb-3">
                        <label for="formulaResult" class="form-label fs-6 fw-semibold" style="font-size: .9rem !important;">Preview Result</label>
                        <input id="formulaResult" type="text" class="form-control fw-medium" style="font-size: .8rem !important;" value="" disabled placeholder="Result will display here">
                    </div>

                </form>
            </div>
            <div class="modal-footer">
                <button class ="btn text-light text-decoration-none cursor-pointer position-absolute start-0 pr-3" title="Reset Form" onclick="handlingFormReset()">
                    <i class="ri-refresh-line text-warning"></i>
                </button>
                @* Delete Button to remove the opened calculated field  *@
                <button type="button" class="btn btn-sm bg-danger-subtle border-0 fw-semibold text-danger-emphasis focus-ring focus-ring-danger" style="display:none; font-size: .8rem !important;" id="deleteFormulaButton" data-bs-toggle="modal" data-bs-target="#deleteConfirmationModal">Delete</button>
                @* Submit button to send form data to the controller  *@
                <button type="submit" class="btn btn-sm bg-primary-subtle border-0 shadow-none text-primary-emphasis fw-semibold  focus-ring focus-ring-primary" style="font-size: .8rem !important;" id="submitFormulaButton" onclick="submitFormula()">Save Calculation</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal for delete confirmation -->
<div class="modal fade bg-dark bg-gradient  bg-opacity-25" id="deleteConfirmationModal" tabindex="-1" aria-labelledby="deleteConfirmationModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header p-2 px-3">
                <h1 class="modal-title fs-6 text-dark" id="deleteConfirmationModalLabel">AerialView</h1>
                <button type="button" class="btn-close btn-sm" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="dashboard-content">
                <p class="fw-bold m-0 text-black"> Are you sure you want to delete this ? </p>
                <span class="text-muted" style="font-size: 14px;"> This action is permanent and cannot be undone. </span>
                <input type="hidden" id="deleteCalcFieldId" />
            </div>
            <div class="modal-footer p-1">
                <button id="deleteBtn" type="button" class="btn btn-sm bg-danger btn-sm text-white shadow-sm" onclick="handleDeleteCalcField()" data-bs-dismiss="modal">Yes</button>
                <button type="button" class="btn btn-sm bg-secondary-subtle btn-sm shadow-sm" data-bs-target="#calculatedFieldModal" data-bs-toggle="modal">No</button>
                @* <button class="btn btn-primary" data-bs-target="#calculatedFieldModal" data-bs-toggle="modal">Open first modal</button> *@
            </div>
        </div>
    </div>
</div>


<script>
    var columnName;
    var formulaVal;
    var saveButton = document.getElementById('submitFormulaButton'); // Save button element
    var calcFieldInput = document.getElementById('calculatedFieldId');
    var deleteCalcField = document.getElementById('deleteCalcFieldId');
    var calcFieldDeleteButton = document.getElementById('deleteFormulaButton');
    var resultInput = document.getElementById('formulaResult');

    // //form validation 
    // (() => {
    //     const form = document.getElementById('formulaForm');
    //     console.log(form)
    //     //prevent submission
    //     form.addEventListener('submit', event=> {
    //         if (!form.checkValidity()) {
    //             event.preventDefault()
    //             event.stopPropagation()
    //         }
             
    //         form.classList.add('was-validated')
    //     }, false )
    // })()

    //handling form reset 
    function handlingFormReset(){
        document.getElementById('formulaForm').reset();
        resultInput.classList.remove('bg-danger-subtle', 'bg-success-subtle');
        document.getElementById('error-message').style.display = 'none';
        calcFieldDeleteButton.style.display = 'none';
    }


    //dropdown selection and fill the input values to with the selected option corresponding column name and formula
    function handleFieldSelection(selectedElement) {
        //selected option
        const selectedOption = selectedElement.options[selectedElement.selectedIndex];
        calcFieldInput.value = selectedOption.value; //setting calculated field hidden input field ID value to the selected dropdown value
        deleteCalcField.value = selectedOption.value;
        const existingFormulaVal = selectedOption.getAttribute('data-formula')
        const existingColumnNameVal = selectedOption.getAttribute('data-column-name')

        const colNameInput = document.getElementById('columnNameInput');
        const formulaInput = document.getElementById('formulaInput');


        colNameInput.value = existingColumnNameVal;
        formulaInput.value = existingFormulaVal;
        handleColumnNameVal(existingColumnNameVal)
        handleFormulaInput(existingFormulaVal);

        //showing delete button only if the one of the valid option is selected from dropdown
        if (selectedElement.value !== "") {
            // Show the delete button if a valid option is selected
            calcFieldDeleteButton.style.display = 'inline-block';
        } else {
            // Hide the delete button if no option is selected
            calcFieldDeleteButton.style.display = 'none';
        }
    }

    //delete calculated field
    function handleDeleteCalcField() {
        $.ajax({
            url: '/ListData/DeleteCalculatedField',
            type: 'POST',
            data: { Id: deleteCalcField.value },
            success: function (response) {
                if (response.success) {
                    DevExpress.ui.notify({
                        message: "Calculated Field deleted successfully",
                        width: 400,
                        type: "success",
                        displayTime: 3500,
                        shading: true,
                        animation: {
                            show: { type: "fade", duration: 400, from: 0, to: 1 },
                            hide: { type: "fade", duration: 40, to: 0 }
                        }
                    }, {
                        position: "bottom center",
                        direction: "up-push"
                    });
                    document.getElementById('formulaForm').reset();
                    resultInput.classList.remove('bg-danger-subtle', 'bg-success-subtle');
                    document.getElementById('error-message').style.display = 'none';
                    calcFieldDeleteButton.style.display = 'none';
                } else {
                    DevExpress.ui.notify({
                        message: "Error saving changes",
                        width: 400,
                        type: "error",
                        displayTime: 3500,
                        shading: true,
                        animation: {
                            show: { type: "fade", duration: 400, from: 0, to: 1 },
                            hide: { type: "fade", duration: 40, to: 0 }
                        }
                    }, {
                        position: "bottom center",
                        direction: "up-push"
                    });
                }

                // Add data-bs-dismiss attribute
                $('#deleteBtn').attr('data-bs-dismiss', 'modal');
            },
            error: function (request, status, error) {
                console.log(error);
                DevExpress.ui.notify({
                    message: "Something went wrong. Please try again.",
                    width: 400,
                    type: "error",
                    displayTime: 3500,
                    shading: true,
                    animation: {
                        show: { type: "fade", duration: 400, from: 0, to: 1 },
                        hide: { type: "fade", duration: 40, to: 0 }
                    }
                }, {
                    position: "bottom center",
                    direction: "up-push"
                });
            }
        });
    }

    //get the column name from user input
    function handleColumnNameVal(value) {
        columnName = value;
    }

    //get the formula input by the user and show its result in the result preview text field
    function handleFormulaInput(value) {
        formulaVal = value;
        validateFormula(value);

        const dataGrid = $('#dataGridContainer').dxDataGrid('instance');
        const firstRow = dataGrid.getVisibleRows()[0]?.data; // Safely get the first visible row of data

        const saveButton = document.getElementById('submitFormulaButton'); // Save button element

        // Regex to check if the formula ends with an operator
        const endsWithOperator = /[+\-*/]$/;

        // Disable the save button if formula ends with an operator
        if (endsWithOperator.test(value.trim())) {
            saveButton.disabled = true; // Disable the button
            resultInput.value = 'Incomplete formula'; // Display an incomplete formula message
            resultInput.classList.add('bg-danger-subtle');
            return;
        }

        if (!firstRow) {
            console.error('No rows available to calculate the formula.');
            resultInput.value = 'Invalid formula'; // Display error message in case of no data
            resultInput.classList.add("bg-danger-subtle");
            saveButton.disabled = true; // Disable the button
            return;
        }

        let result = 0;
        let isValid = true;  // Flag to track if the formula is valid

        try {
            // Modify regex to correctly parse column names and allow numbers directly
            // let formula = formulaVal.replace(/([A-Za-z0-9_]+)/g, function (match) { /* <-- This was Razor syntax */
            let formula = formulaVal.replace(/([A-Za-z_]\w*)|\d+/g, function (match) {
                const trimmedMatch = match.trim();  // Trim spaces around column names
                // Check if the trimmed column name exists in the first row (case-sensitive)
                if (firstRow.hasOwnProperty(trimmedMatch)) {
                    return firstRow[trimmedMatch] !== undefined ? firstRow[trimmedMatch] : 0; // Use value if exists, otherwise use 0
                } else {
                    // Check if the match is a valid number (not a column)
                    const numValue = parseFloat(trimmedMatch);
                    if (!isNaN(numValue)) {
                        return numValue; // Return the number directly if it's valid
                    } else {
                        isValid = false;  // If the column doesn't exist and it's not a number, mark the formula as invalid
                        console.error(`Column "${trimmedMatch}" does not exist.`);
                        return 0;  // Return 0 to avoid breaking the formula
                    }
                }
            });

            // Evaluate the formula using Function constructor to avoid security issues with eval
            if (isValid) {
                const evaluateFormula = new Function('return ' + formula);
                result = evaluateFormula();
                // Round the result to 12 decimal places
                result = parseFloat(result.toFixed(2));
            } else {
                result = 'Invalid formula';  // Set result to "Invalid formula" if any column was missing
            }
        } catch (error) {
            console.error("Error in formula: ", error);
            result = 'Invalid formula';  // In case of any other errors
        }

        // resultInput.value = result || 'Invalid formula'; // Set the result or display 'Invalid formula'
        // Set the result or show a specific message for zero
        resultInput.value = result; // Directly set the result


        // Remove any previous background color classes
        resultInput.classList.remove('bg-danger-subtle', 'bg-success-subtle');

        // Change background color based on the result
        if (isNaN(result)) {
            resultInput.classList.add('bg-danger-subtle'); // Invalid formula
        } else {
            resultInput.classList.add('bg-success-subtle'); // Valid formula
        }

        // Toggle the disabled state of the button based on formula validation
        const submitButton = document.getElementById('submitFormulaButton');
        submitButton.disabled = !isValid;
    }


    // Validate the formula to check if all referenced columns exist
    function validateFormula(formula) {
        const dataGrid = $('#dataGridContainer').dxDataGrid('instance');
        const columns = dataGrid.option('columns').map(col => col.dataField.trim()); // Trim spaces from column names

        var errorMessage = document.getElementById('error-message'); // Error message element for formula validation

        // Remove existing error messages
        if (errorMessage) {
            errorMessage.style.display = 'none';
        }

        // Regex to extract potential column names or numbers, ignoring spaces
        const columnRegex = /([A-Za-z_]\w*)|\d+/g;
        let match;
        let invalidColumns = [];

        // Check each part in the formula
        while ((match = columnRegex.exec(formula)) !== null) {
            const trimmedMatch = match[0].trim(); // Trim the matched part

            // Check if the match is a valid column name
            if (isNaN(trimmedMatch) && !columns.includes(trimmedMatch)) {
                // Only check against column names if it's not a number
                invalidColumns.push(trimmedMatch); // Collect invalid column names
            }
        }

        if (invalidColumns.length > 0) {
            if (invalidColumns.length === 1) {
                errorMessage.innerHTML = `Column "${invalidColumns[0]}" currently does not exist in the table!`; // Singular
            } else {
                errorMessage.innerHTML = `Columns "${invalidColumns.join(', ')}" currently do not exist in the table!`; // Plural
            }
            errorMessage.style.display = 'block'; // Show error message
        } else {
            // All columns are valid, hide error message
            errorMessage.style.display = 'none';
        }
    }

    //submit the formula to the backend and add its column in the grid at the same time
    function submitFormula() {
        var calculatedColName = columnName;
        var formula = formulaVal; // Get the formula input
        var rptId = parseInt(document.querySelector('input[name="rptId"]').value); // Convert rptId to integer
        var calculatedFieldId = calcFieldInput.value; // Convert Id to integer

        // Set Id to null if it's an empty string
        calculatedFieldId = calculatedFieldId === '' ? null : parseInt(calculatedFieldId);

        // Prepare the data to be sent
        var formData = {
            ColumnName: calculatedColName,
            Formula: formula,
            RptId: rptId,
            Id: calculatedFieldId
        };

        $.ajax({
            url: '/ListData/InsertCalculatedField',
            type: 'POST',
            data: JSON.stringify(formData),
            contentType: 'application/json',
            success: function (response) {
                if (response.success) {
                    DevExpress.ui.notify({
                        message: "Formula submitted successfully",
                        width: 300,
                        type: "success",
                        displayTime: 3500,
                        shading: true,
                        animation: {
                            show: { type: "fade", duration: 400, from: 0, to: 1 },
                            hide: { type: "fade", duration: 40, to: 0 }
                        }
                    }, {
                        position: "bottom center",
                        direction: "up-push"
                    });
                    addCalculatedColumn();
                    document.getElementById('formulaForm').reset();
                    resultInput.classList.remove('bg-danger-subtle', 'bg-success-subtle');
                    document.getElementById('error-message').style.display = 'none';
                    calcFieldDeleteButton.style.display = 'none';
                } else {
                    DevExpress.ui.notify({
                        message: "Error saving changes",
                        width: 300,
                        type: "error",
                        displayTime: 3500,
                        shading: true,
                        animation: {
                            show: { type: "fade", duration: 400, from: 0, to: 1 },
                            hide: { type: "fade", duration: 40, to: 0 }
                        }
                    }, {
                        position: "bottom center",
                        direction: "up-push"
                    });
                }
            },
            error: function (xhr, status, error) {
                console.error('Error updating data:', xhr.responseText || error);
                // DevExpress.ui.notify('Error updating data to the backend', 'error', { position: "center", direction: "up-push" }, 2000);
                DevExpress.ui.notify({
                    message: "An error occured. Please try again.",
                    width: 300,
                    type: "error",
                    displayTime: 3500,
                    shading: true,
                    animation: {
                        show: { type: "fade", duration: 400, from: 0, to: 1 },
                        hide: { type: "fade", duration: 40, to: 0 }
                    }
                }, {
                    position: "bottom center",
                    direction: "up-push"
                });
            }
        });

    }

    //add calculated column to the datagrid at the button click while also saving the grid previous state
    function addCalculatedColumn() {
        const dataGrid = $('#dataGridContainer').dxDataGrid('instance');
        if (dataGrid) {
            // Save the current state
            const gridState = localStorage.getItem('storage');
            const columns = dataGrid.option('columns');

            // Adding new column
            columns.push({
                dataField: columnName,
                caption: columnName,
                calculateCellValue: function (e) {
                    try {
                        // Construct the formula by replacing column names with e.<column_name>
                        let formula = formulaVal.replace(/([A-Za-z_]\w*)/g, function (match) {
                            return `e.${match}`; // Replace valid column names
                        });

                        // Evaluate the constructed formula
                        // Use Function constructor to avoid eval's security issues and syntax errors
                        const evaluateFormula = new Function('e', `return ${formula};`);
                        return evaluateFormula(e);
                    } catch (error) {
                        console.error("Error in formula: ", error);
                        return null; // Return null if formula cannot be calculated
                    }
                },
                dataType: 'number',
                cssClass: "datagridCol",
                format: {
                    type: 'fixedPoint',
                    precision: 2
                }
            });

            // Update the grid with the new columns array
            dataGrid.option('columns', columns);

            // Restore the state
            if (gridState) {
                dataGrid.state(JSON.parse(gridState));
            }

            // Notify the user
            DevExpress.ui.notify({
                message: ` '${columnName}' column added successfully`,
                width: 300,
                type: "success",
                displayTime: 3500,
                shading: true,
                animation: {
                    show: { type: "fade", duration: 400, from: 0, to: 1 },
                    hide: { type: "fade", duration: 40, to: 0 }
                }
            }, {
                position: "bottom center",
                direction: "up-push"
            });
        }
    }



    // Function to dynamically update the editing state of the DataGrid
    window.updateDataGridEditing = function (isEditingEnabled) {
        const dataGrid = $('#dataGridContainer').dxDataGrid('instance');
        if (dataGrid) {
            dataGrid.option('editing.allowUpdating', isEditingEnabled);
        }
    };

    // checking editing state is enabled or not  on page load
    document.addEventListener('DOMContentLoaded', () => {
        const isEditingEnabled = localStorage.getItem('isEditingEnabled') === 'true';
        window.updateDataGridEditing(isEditingEnabled);
    });

    //converting date and time data from object to string and returning it in sql format
    function formatDateToSQL(date) {
        const yyyy = date.getFullYear();
        const mm = String(date.getMonth() + 1).padStart(2, '0'); // Months are zero-based
        const dd = String(date.getDate()).padStart(2, '0');
        const hh = String(date.getHours()).padStart(2, '0');
        const min = String(date.getMinutes()).padStart(2, '0');
        const ss = String(date.getSeconds()).padStart(2, '0');

        // Return in 'YYYY-MM-DD HH:mm:ss' format
        return `${yyyy}-${mm}-${dd} ${hh}:${min}:${ss}`;
    }

    //update the table after editing
    function onSaving(e) {
        var changes = e.changes;

        // Fetch table name and connection string from the data attributes
        var tableName = $('#dataTable').data('table-name');
        var connString = $('#dataTable').data('conn-string');

        if (changes.length > 0) {
            var updatedData = changes.map(change => {
                const convertedData = { ...change.data };

                // Convert date fields in change.data
                for (const key in convertedData) {
                    if (convertedData[key] instanceof Date) {
                        convertedData[key] = formatDateToSQL(convertedData[key]);
                    }
                }

                // Explicitly convert DateAndTime if it is a Date object
                if (convertedData.DateAndTime instanceof Date) {
                    convertedData.DateAndTime = formatDateToSQL(convertedData.DateAndTime);
                }

                return {
                    ...change.key,
                    ...convertedData
                };
            });

            $.ajax({
                url: '@Url.Action("UpdateDataGrid", "ListData")',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({
                    tableName: tableName,
                    changes: updatedData,
                    connString: connString
                }),
                success: function (response) {
                    if (response.success) {
                        // DevExpress.ui.notify('Changes saved successfully', 'success', { position: "center", direction: "up-push" }, 2000);
                        DevExpress.ui.notify({
                            message: "Changes saved successfully",
                            width: 300,
                            type: "success",
                            displayTime: 3500,
                            shading: true,
                            animation: {
                                show: { type: "fade", duration: 400, from: 0, to: 1 },
                                hide: { type: "fade", duration: 40, to: 0 }
                            }
                        }, {
                            position: "bottom center",
                            direction: "up-push"
                        });

                    } else {
                        // DevExpress.ui.notify('Error saving changes', 'error', { position: "center", direction: "up-push" }, 2000);
                        DevExpress.ui.notify({
                            message: "Error saving changes",
                            width: 300,
                            type: "error",
                            displayTime: 3500,
                            shading: true,
                            animation: {
                                show: { type: "fade", duration: 400, from: 0, to: 1 },
                                hide: { type: "fade", duration: 40, to: 0 }
                            }
                        }, {
                            position: "bottom center",
                            direction: "up-push"
                        });
                    }
                },
                error: function (xhr, status, error) {
                    console.error('Error updating data:', xhr.responseText || error);
                    // DevExpress.ui.notify('Error updating data to the backend', 'error', { position: "center", direction: "up-push" }, 2000);
                    DevExpress.ui.notify({
                        message: "Error updating data to the backend",
                        width: 300,
                        type: "error",
                        displayTime: 3500,
                        shading: true,
                        animation: {
                            show: { type: "fade", duration: 400, from: 0, to: 1 },
                            hide: { type: "fade", duration: 40, to: 0 }
                        }
                    }, {
                        position: "bottom center",
                        direction: "up-push"
                    });
                }
            });
        }
    }

    //show loading spinner before datagrid load
    function showLoadingSpinner() {
        $("#loadingSpinner").removeClass("d-none");
        $("#noDataMessage").addClass("d-none");
        $("#errorMessage").addClass("d-none");
    }

    //hide loading spinner on data load
    function hideLoadingSpinner() {
        $("#loadingSpinner").addClass("d-none");
    }

    //show no data error message
    function showNoDataMessage() {
        $("#noDataMessage").removeClass("d-none");
        $("#loadingSpinner").addClass("d-none");
        $("#errorMessage").addClass("d-none");
    }

    //error message
    function showErrorMessage() {
        $("#errorMessage").removeClass("d-none");
        $("#loadingSpinner").addClass("d-none");
        $("#noDataMessage").addClass("d-none");
    }

    var excelExportBtn = document.getElementById('excelExportButton');
    var pdfExportBtn = document.getElementById('pdfExportButton');
    var pdfOrientationSelect = document.getElementById('pdfOrientationSelect');


    if (excelExportBtn) {
        excelExportBtn.addEventListener('click', function (event) {
            exportGridToExcel(event);
        });
    }

    if (pdfExportBtn) {
        pdfExportBtn.addEventListener('click', function (event) {
            exportGridToPdf(event);
        });
    }

    var tableData = @Html.Raw(Json.Serialize(Model.TableData));
    var clientData = @Html.Raw(Json.Serialize(Model.PdfImageData));

    // Get the current date and time
    var date = new Date();
    var formattedDate = date.getDate() + '-' + date.getMonth() + '-' + date.getFullYear();
    var formattedTime = date.getHours() + '' + date.getMinutes() + '' + date.getSeconds();

    // Export grid data to Excel
    function exportGridToExcel(e) {
        var tableName = document.getElementById('dataTable').getAttribute('data-table-name');
        var childMenuName = document.getElementById('dataTable').getAttribute('data-child-menu-name');

        // DataGrid instance
        var dataGridElement = document.getElementById("dataGridContainer");
        var dataGridInstance = DevExpress.ui.dxDataGrid.getInstance(dataGridElement);

        var workbook = new ExcelJS.Workbook();
        var worksheet = workbook.addWorksheet(tableName);

        // Merge cells and add image to the workbook
        worksheet.mergeCells("A1:A4");
        const imageId = workbook.addImage({
            base64: clientData[0].Logo,
            extension: 'jpeg',
        });

        //fixed dimensions for the image
        const imageWidth = 150;
        const imageHeight = 80;

        worksheet.addImage(imageId, {
            tl: { col: 0, row: 0 },
            ext: { width: imageWidth, height: imageHeight }
        });

        // Get visible columns only
        var visibleColumns = dataGridInstance.getVisibleColumns();

        DevExpress.excelExporter.exportDataGrid({
            component: dataGridInstance,
            worksheet: worksheet,
            autoFilterEnabled: true,
            topLeftCell: { row: 5, column: 1 },
            customizeCell: function (options) {
                var gridCell = options.gridCell;
                var excelCell = options.excelCell;

                if (gridCell.rowType === "header") {
                    var column = visibleColumns[gridCell.columnIndex];
                    if (column) {
                        excelCell.value = column.caption;
                    }
                }
            }
        }).then(function () {
            // Format column headers with bold text
            var headerRow = worksheet.getRow(5);
            headerRow.font = { bold: true };

            headerRow.eachCell(function (cell, colNumber) {
                cell.fill = {
                    type: 'pattern',
                    pattern: 'solid',
                    fgColor: { argb: 'ffffffcc' }
                };

                cell.border = {
                    top: { style: 'thin' },
                    left: { style: 'thin' },
                    bottom: { style: 'thin' },
                    right: { style: 'thin' }
                };
            });

            function getColumnLetter(columnIndex) {
                var columnName = '';
                while (columnIndex > 0) {
                    var remainder = (columnIndex - 1) % 26;
                    columnName = String.fromCharCode(65 + remainder) + columnName;
                    columnIndex = Math.floor((columnIndex - 1) / 26);
                }
                return columnName;
            }

            var headerLength = visibleColumns.length;
            var last = getColumnLetter(headerLength);

            worksheet.mergeCells('B3:' + last + '3');
            worksheet.getCell('B3').value = tableName;
            worksheet.getCell('B3').alignment = { horizontal: 'center', vertical: 'middle' };
            worksheet.getCell('B3').font = { bold: true, name: 'Arial' };
            worksheet.getCell('B3').fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFDDDDDD' }
            };

            // Set ProjectName in cell B2
            worksheet.mergeCells('B2:' + last + '2');
            worksheet.getCell('B2').value = clientData[0].ProjectName;
            worksheet.getCell('B2').alignment = { horizontal: 'center', vertical: 'middle' };
            worksheet.getCell('B2').font = { bold: true, name: 'Arial' };
            worksheet.getCell('B2').fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFFFFFFF' }
            };

            // Set ClientName in cell B1
            worksheet.mergeCells('B1:' + last + '1');
            worksheet.getCell('B1').value = clientData[0].ClientName;
            worksheet.getCell('B1').alignment = { horizontal: 'center', vertical: 'middle' };
            worksheet.getCell('B1').font = { bold: true, name: 'Arial' };
            worksheet.getCell('B1').fill = {
                type: 'pattern',
                pattern: 'solid',
                fgColor: { argb: 'FFDDDDDD' }
            };

            // Loop through all cells and add borders
            worksheet.eachRow({ includeEmpty: true }, function (row, rowNumber) {
                row.eachCell({ includeEmpty: true }, function (cell, colNumber) {
                    cell.border = {
                        top: { style: 'thin' },
                        left: { style: 'thin' },
                        bottom: { style: 'thin' },
                        right: { style: 'thin' }
                    };
                });
            });

            workbook.xlsx.writeBuffer().then(function (buffer) {
                var fileName = childMenuName + '_' + formattedDate + '_' + formattedTime + '.xlsx';
                saveAs(new Blob([buffer], { type: 'application/octet-stream' }), fileName);
            });
        });
    }


    // Export grid data to PDF
    function exportGridToPdf(e) {
        var tableName = document.getElementById('dataTable').getAttribute('data-table-name');
        var orientation = pdfOrientationSelect.value; //portrait or landscape

        // DataGrid instance
        var dataGridElement = document.getElementById("dataGridContainer");
        var dataGridInstance = DevExpress.ui.dxDataGrid.getInstance(dataGridElement);



        var rowHeight = 10;
        var columnCount = dataGridInstance.columnCount();
        console.log("columnCount", columnCount)
        var rowCount = dataGridInstance.getDataSource().items().length;

        var columnWidth;

        if (columnCount >= 15) {
            columnWidth = 14.5;
        } else {
            columnWidth = 19;
        }


        var margin = {
            top: 25,
            bottom: 20,
            left: 15,
            right: 15
        };

        // Calculate required width and height
        var totalWidth = columnCount * columnWidth + margin.left + margin.right;
        var totalHeight = rowCount * rowHeight + margin.top + margin.bottom;


        // Define custom sizes for landscape orientation
        var landscapeWidth = 500;
        var landscapeHeight = 297; // Standard A4 height for landscape

        // Set page size based on orientation and content size
        var pageFormat = (orientation === 'landscape')
            ? [totalWidth + 15, landscapeHeight] // Landscape
            : [210, 297]; // Portrait
        // : [290, 250]; // Portrait


        // Initialize jsPDF with custom page size
        var doc = new jsPDF({
            orientation: orientation,
            unit: 'mm', // Millimeters for accurate margins and dimensions
            // format: pageFormat
            format: 'a4'
        });

        // Function to add header content
        var addHeader = function () {
            doc.setFontSize(13);
            doc.setTextColor(0);
            doc.text(tableName + ' ' + 'Table', doc.internal.pageSize.getWidth() / 2, 15, { align: 'center' });

            // Add logo, project name, client name
            var item = clientData[0];
            var imgData = item.Logo;
            var projectName = item.ProjectName;
            var clientName = item.ClientName;

            doc.addImage(imgData, 'JPEG', 15, 25, 25, 15);

            doc.setFontSize(11);
            doc.text('Project: ' + projectName, doc.internal.pageSize.getWidth() / 2, 31, { align: 'center' });
            doc.text('Client: ' + clientName, doc.internal.pageSize.getWidth() / 2, 37, { align: 'center' });
            doc.setTextColor(0);
            doc.setFontSize(0);
        };

        // Call addHeader for the first page
        addHeader();

        // Export data grid to PDF
        DevExpress.pdfExporter.exportDataGrid({
            jsPDFDocument: doc,
            component: dataGridInstance,
            topLeft: { x: 1, y: 30 }, // Adjust the x and y values to start the table lower
            columnWidths: Array(columnCount).fill(columnWidth),
            // indent: 5,
            customizeCell: function (options) {
                const { gridCell, pdfCell } = options;

                if (gridCell.rowType === 'data') { //for table content other than headers
                    pdfCell.font = { size: 6 };

                } else if (gridCell.rowType === 'header') { //for table headers
                    pdfCell.font = { size: 8, style: 'bold' };
                    pdfCell.backgroundColor = '#D3D3D3'; //Light grey background
                    pdfCell.textColor = '#000000';
                    pdfCell.fontStyle = 'bold';
                } else if (gridCell.rowType === 'group') {
                    pdfCell.backgroundColor = '#DCDCDC';
                }
            }
        }).then(function () {
            // Calculate the number of pages
            var pageCount = doc.internal.getNumberOfPages();

            // Add footer to each page
            for (var i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                addFooter(i, pageCount); // Add footer with page number
            }

            var fileName = tableName + '_' + formattedDate + '_' + formattedTime;
            // Save the PDF document
            doc.save(fileName);
        });

        // Function to add footer with paging
        var addFooter = function (pageNumber, pageCount) {
            doc.setFontSize(9);
            doc.setTextColor('#cccccc');
            doc.text('Page ' + pageNumber + ' of ' + pageCount, doc.internal.pageSize.getWidth() / 2, doc.internal.pageSize.getHeight() - 10, { align: 'center' });
        };
    }

</script>